# -*- coding: utf-8 -*-
"""R_DL_Best_Fit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fUER6AX6_Uo3TQWsSXoibRuEAtFXarvX
"""

!pip install gradio contractions
!pip install tensorflow

import pandas as pd
import numpy as np
import re
import string
import contractions
import seaborn as sns
import matplotlib.pyplot as plt
import pickle
import gradio as gr

from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense, Dropout, Bidirectional
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.utils import to_categorical


df = pd.read_csv('/content/Reviews.csv')
df = df[['Text', 'Score']].dropna()

def map_sentiment(score):
    if score <= 2:
        return 0
    elif score == 3:
        return 1
    else:
        return 2

df['Sentiment'] = df['Score'].apply(map_sentiment)

print("\nDistribution of Review Scores:")
sns.countplot(x='Score', data=df)
plt.title("Distribution of Review Scores")
plt.show()

print("\nSentiment Count:")
sns.countplot(x='Sentiment', data=df)
plt.title("Sentiment Class Distribution (0 = Neg, 1 = Neutral, 2 = Pos)")
plt.show()

df['TextLength'] = df['Text'].apply(len)
plt.figure(figsize=(10, 5))
sns.histplot(df['TextLength'], bins=30, kde=True)
plt.title("Review Text Length Distribution")
plt.xlabel("Text Length")
plt.show()

def preprocess_text(text):
    text = str(text).lower()
    text = contractions.fix(text)
    text = re.sub(r"http\S+|www\S+|https\S+", '', text)
    text = re.sub(r"[^a-zA-Z\s]", "", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text

def next_word_negation(text):
    words = text.split()
    negation_words = {"not", "no", "never", "n't"}
    new_words = []
    negate = False
    for word in words:
        if word in negation_words:
            negate = True
        elif negate:
            new_words.append("not_" + word)
            negate = False
        else:
            new_words.append(word)
    return " ".join(new_words)

df['Cleaned_Text'] = df['Text'].apply(preprocess_text).apply(next_word_negation)

max_words = 10000
max_len = 200

tokenizer = Tokenizer(num_words=max_words)
tokenizer.fit_on_texts(df['Cleaned_Text'])
sequences = tokenizer.texts_to_sequences(df['Cleaned_Text'])

X = pad_sequences(sequences, maxlen=max_len)
y = to_categorical(df['Sentiment'], num_classes=3)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = Sequential([
    Embedding(input_dim=max_words, output_dim=128, input_length=max_len),
    Bidirectional(LSTM(64, return_sequences=True)),
    Dropout(0.3),
    LSTM(32),
    Dense(32, activation='relu'),
    Dropout(0.2),
    Dense(3, activation='softmax')
])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

history = model.fit(X_train, y_train, epochs=4, batch_size=128, validation_split=0.1)

y_pred_probs = model.predict(X_test)
y_pred = y_pred_probs.argmax(axis=1)
y_true = y_test.argmax(axis=1)

print("\nClassification Report:")
print(classification_report(y_true, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_true, y_pred))

with open("tokenizer.pkl", "wb") as f:
    pickle.dump(tokenizer, f)

model.save("sentiment_model.h5")

def predict_sentiment(review):
    review = preprocess_text(review)
    review = next_word_negation(review)
    seq = tokenizer.texts_to_sequences([review])
    padded = pad_sequences(seq, maxlen=max_len)
    pred = model.predict(padded)[0]
    label_map = {0: "Negative 😞", 1: "Neutral 😐", 2: "Positive 😊"}
    sentiment = label_map[np.argmax(pred)]
    confidence = f"{np.max(pred) * 100:.2f}%"
    return f"Sentiment: {sentiment}\nConfidence: {confidence}"

interface = gr.Interface(
    fn=predict_sentiment,
    inputs=gr.Textbox(lines=5, placeholder="Enter a product review..."),
    outputs="text",
    title="📦 Product Review Sentiment Analyzer (3-Class)",
    description="Enter a product review below and get a prediction (Positive, Neutral, Negative) using an LSTM model.",
    theme="default"
)

interface.launch(share=True)

